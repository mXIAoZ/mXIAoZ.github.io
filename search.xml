<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>How to think about psychology 1-2</title>
    <url>/2021/05/27/How-to-think-about-psychology-1-2/</url>
    <content><![CDATA[<h1 id="这才是心理学（1-2）How-to-think-about-psychology"><a href="#这才是心理学（1-2）How-to-think-about-psychology" class="headerlink" title="这才是心理学（1-2）How to think about psychology"></a>这才是心理学（1-2）How to think about psychology</h1><h2 id="第一章-心理学介绍"><a href="#第一章-心理学介绍" class="headerlink" title="第一章 心理学介绍"></a>第一章 心理学介绍</h2><p>&emsp;心理学作为一门科学，研究的是人类以及动物的行为，并且依据研究对行为做出预测。作者认为心理学和其他科学一样，是基于数据的科学的研究，但是心理学相对于其他科学如物理学、化学等，是一门较为“年轻”的学科。</p>
<p>&emsp;人们对于西格蒙德 <script type="math/tex">\cdot</script> 佛洛伊德精神分析的“心理学理论”印象深刻，但是正如发展心理学家艾莉森 <script type="math/tex">\cdot</script> 戈伯尼克所说佛罗伊徳理论是一种僵尸理论，它彻底误导了大众对于心理学徳印象。因为，其理论并不是建立在科学的研究之上得出的结论，而是依附于佛洛依德的个案研究以及自省。</p>
<span id="more"></span>
<p>&emsp;作者在第一章为心理学辟谣，并且简要介绍了心理学的多样性以及统一性。同时指出，定义科学的三个相互关联的特征：</p>
<p>​    &emsp;&emsp;（1）系统实证主义的运用。即科学家通过检验来认识世界。</p>
<p>​    &emsp;&emsp;（2）公共知识的产生。即可重复性和同行评审（peer review）。</p>
<p>​    &emsp;&emsp;（3）对可解决问题的细查。即处理的是可解决的、可具体指明的问题。</p>
<p>&emsp;心理学作为一门科学，也必须满足上述三个特征。</p>
<p>&emsp;世俗智慧（常识）作为对行为的内隐“解释”是难以驳倒的，因为不管发生什么事都可以有一些包含世俗智慧的谚语来解释。同时无法反驳也造成了这些理论的无用性。即使有一些世俗信念可以进行实证检验，但是通过心理学研究可以发现许多常见的关于行为的文化信念都是错误的。虽然有一些世俗信念被证明是错误的，但是新的传言层出不穷。如果人们意识到这种世俗信念的易错性，那么民众心理学的问题就不会那么具有危害性。但是，超过80%的公众认为日常生活提供了足够的心理学训练，但是这恰恰相反。心理学作为世俗智慧的验证者，往往会与根深蒂固的文化信念相冲突，从而不被接受。</p>
<h2 id="第二章-可证伪性"><a href="#第二章-可证伪性" class="headerlink" title="第二章 可证伪性"></a>第二章 可证伪性</h2><p>&emsp;作者在第一章强调了心理学的科学性同时提醒读者要警惕一些世俗智慧的危害，保持批判的思维。</p>
<p>&emsp;作者在第二章强调了心理学的可证伪性。作者认为理论不是用来解释结果的，而是用来预测结果。结果是对理论的证明。这也是科学中证伪性的重要性所在，证伪性是知预测的结果可以用来证明理论的错误，越清晰的预测结果越能证明理论的正确性，预测的数量多并不能表示理论有多正确。</p>
<p>&emsp;作者同时指出，科学就是在不断证伪的过程中向前发展的。如果理论在实验中被证实，那么理论就得到了某种程度上的确认，如果被证伪，就必须对理论做出改变或者提出一个新的更加逼近真理的理论来取代。</p>
<p>&emsp;如果一个理论不可证伪，那么它对自然界中的实际时间就没有任何意义即使无用的。心理学一直被不可证伪的理论所困扰，也是其发展缓慢的原因之一。</p>
<h2 id="较有感触的句子"><a href="#较有感触的句子" class="headerlink" title="较有感触的句子"></a>较有感触的句子</h2><p>“现代思潮中一个危险的趋势是，应避免让普罗大众知道世界的本质：一种无知的面纱是必要的，以保护没有能力应对那些真相的公众。”</p>
<p>&emsp;同作者一样，反对这一观点。人们有权利了解世界的本质，相信与否取决于个人。人们是否需要规避让自己感到不适的发现应由个人所决定，而不是其他组织。</p>
]]></content>
      <categories>
        <category>Psychology</category>
        <category>How to think about psychology</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>心理学</tag>
        <tag>这才是心理学</tag>
      </tags>
  </entry>
  <entry>
    <title>How to think about psychology 11-12</title>
    <url>/2021/06/02/How-to-think-about-psychology-11-12/</url>
    <content><![CDATA[<h1 id="这才是心理学（11-12）How-to-think-about-psychology"><a href="#这才是心理学（11-12）How-to-think-about-psychology" class="headerlink" title="这才是心理学（11-12）How to think about psychology"></a>这才是心理学（11-12）How to think about psychology</h1><p>&emsp;接近一周的对于这本心理学入门的书籍进行的笔记也结束了，后续会针对整本书进行一个总结和回顾吧。</p>
<h2 id="第十一章-偶然性"><a href="#第十一章-偶然性" class="headerlink" title="第十一章 偶然性"></a>第十一章 偶然性</h2><p>&emsp;本章继续第10章介绍的概率，单独将概率中的偶然性拿出来进行讨论。</p>
<p>&emsp;首先，作者介绍了人们为什么对偶然性执迷不悟，同时指出偶然性的危害。</p>
<p>&emsp;人类大脑的进化方式，使得人类不懈地寻求世界中的各种模式，这也是人类智力的特征，促使了人类在信息处理和知识获取方面取得了辉煌的成就。但是，这种对于偶然性解释的进化，有时也会产生不好的效果。如一些金融分析师试图对每一次股市价格的微小波动做出解释，但是这种波动大部分情况下都是随机的，他们的执着于解释这些是为了让人们相信他们可以打败市场。同时即使有些人真的预测到一些变化，这种预测也是不可靠的。简单来说，假设将预测分为下跌和上涨两种情况，有1000人对第一次变化进行了预测，那么就会有500人可以对这次变化成功预测，这500人接着对第二次变化进行了预测，那么就会有250人对第二次变化成功预测，直到进行到第四次预测，那么仍然会有60人左右连着预测正确四次。因此，从概率上来说，总会有人在接下来的预测取得了成功，但是这些是不可靠的。</p>
<span id="more"></span>
<p>&emsp;同时，作者指出偶然性和随机性并不是在原则上具有不确定性，而是当下无法确定。例如，在生物学足够发达的情况下，我们或许能够解释为什么有些吸烟者不会患有肺癌，但是当下这种可变性必须归因于大量的偶然因素。</p>
<p>&emsp;人们有解释偶然事件的倾向，这一现象在心理学的研究中被称为相关错觉。许多控制研究都表明，当人么预设两个变量有关联时，即使在两个变量毫无关系的数据中，他们也会发现联系。当然，认为生活中每一件偶然的小事都需要精细的解释，这种想法是错误的。</p>
<p>&emsp;接着，作者解释了为什么人们误解了生活中的巧合。在事件中寻求模式和意义的倾向，加上巧合的“不可思议”特性，让许多人会忘记用偶然性来解释巧合，反而为理解这些事情寻求复杂的理论。其实，概率定律确保了随着事件发生的次数的增加，一些罕见匹配出现的概率会变得非常高，这一定律不仅允许罕见匹配的出现，而且从长远来看几乎保证了它的出现。例如，假设一个人每天都会参与100件不同的事（看电视、打电话等都可以拆分为几个单独的事件，因此可能不止100），那么所有事件的组合有4950种，一年365天，会得到18 067 500个匹配，所以在一年中一个罕见匹配发生的概率为0.00000033，因此一年出现多个罕见匹配并不奇怪。人们对于个人巧合不愿意去归因于偶然，可能具有一些动机性和情感性，但是实际上巧合发生的概率并不小。</p>
<p>&emsp;最后，作者指出要接受错误以减少错误。拒绝承认偶然因素的作用，会降低我们对现实世界的预测能力。承认预测会出现错误，有助于提高整体预测的准确性。如，假设两盏灯蓝和红分别以70%和30%的概率出现，那么在已知蓝灯亮的概率比红灯大时，随机预测准确的概率为58%（70 <em> 0.7 + 30 </em> 0.3），小于每次都预测蓝灯亮的概率70%。同时，有些人也会提出群体统计不适用于单个个体或单个事件，但是很多研究已经证明，即使临床医生可以获得比统计方法更多的信息，但是统计预测仍然比临床医生的预测更加准确！因此，在试图为每一个不同寻常的案例寻求独特的解释时，往往会使我们失去了对更常见的个案的预测。对于心理学来说，预测应该是概率性的，是对总体趋势的预测。</p>
<h2 id="第十二章-不招人待见的心理学"><a href="#第十二章-不招人待见的心理学" class="headerlink" title="第十二章 不招人待见的心理学"></a>第十二章 不招人待见的心理学</h2><p>&emsp;本章作者主要说明了心理学为大众所怀疑的种种原因。</p>
<p>&emsp;心理学的形象问题。在书店中的心理学读物可以分为三种：1. 少数几本心理学早期经典著作，但是这些多半侧重老式的精神分析观点，完全不能代表当代心理学。2. 伪装成心理学的伪科学书籍，如心灵感应、意念移物等，但是在心理学领域，超感官感知的研究常常是不可靠也不能重复的。3. 一些自助类读物如励志类、人类行为的老生常谈以及没有科学依据的“新疗法”。然而许多经过严格的心理学检验被证明有效的认知和行为疗法，很少出现在书架上。互联网上的情况也是类似。</p>
<p>&emsp;作者认为许多跨学科的研究，涉及到心理学家的贡献时，往往会被忽略。</p>
<p>&emsp;最后作者指出自己是最坏的敌人。如罗宾 道斯和斯科特 利连菲尔德所反对的，心理学领域基于心理学的科学性来颁发资格认证，然后又用资格认证来保护心理学从业者的不科学行为。同时作者也指出，心理学正在逐渐成为的单一的意识形态文化。每个人都有一套关于人类行为的理论，凡是千万不要把个人的心理学理论与科学心理学混为一谈。</p>
<p>&emsp;作者在本章花了很多篇幅用于作为心理学家的自我反省，或者说对整个心理学界进行反省，这也告诫我们，不要认为科学家的行为也是科学的，这些往往也是个人偏见所作出的一些行为。同时告诫读者，要警惕伪科学和伪心理学。</p>
]]></content>
      <categories>
        <category>Psychology</category>
        <category>How to think about psychology</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>心理学</tag>
        <tag>这才是心理学</tag>
      </tags>
  </entry>
  <entry>
    <title>How to think about psychology 5-7</title>
    <url>/2021/05/31/How-to-think-about-psychology-5-7/</url>
    <content><![CDATA[<h1 id="这才是心理学（5-7）How-to-think-about-psychology"><a href="#这才是心理学（5-7）How-to-think-about-psychology" class="headerlink" title="这才是心理学（5-7）How to think about psychology"></a>这才是心理学（5-7）How to think about psychology</h1><h2 id="第五章-相关性与因果关系问题"><a href="#第五章-相关性与因果关系问题" class="headerlink" title="第五章 相关性与因果关系问题"></a>第五章 相关性与因果关系问题</h2><p>&emsp;本章主要向读者解释两个变量具有相关性并不表示这两个变量存在因果关系。</p>
<p>&emsp;第三变量的存在会使两个变量之间产生误导性关联，这种第三变量有时候并不是很容易分辨。在“使用“烤箱法”避孕”这个案列中，可以很清楚的意识到由于经济水平的不同，导致了使用的避孕方法/工具的不同，从而影响到避孕效果，然而经济水平较高的家庭中往往会有一些高级家具如烤箱等，因此烤箱和避孕在调查中虽然显示了一定的联系，但是第三变量的存在（经济水平）才是正确的因果关系。当一些因果关系在常识看来是显而易见时，或者当我们带着强烈的预设偏见或者我们的理论取向支配了我们对现象的解释时，相关性很容易被视为因果关系的证据。</p>
<span id="more"></span>
<p>&emsp;当第三变量被排除之后，还有必要确定因果关系的方向，即方向性问题。如在新赫布里底群岛上生活的岛民认为，虱子使人健康，因为健康的人相较于非健康的人身上有更多的虱子。但是实际原因是，不健康的人会更快地发烧，从而杀死虱子。因此是不健康导致了虱子较少，而不是虱子少导致了不健康。</p>
<p>&emsp;选择偏差同样是导致许多虚假相关产生的原因。“自我选择偏差”指的是人们自己选择进入一个特定地群体。自我选择会导致个人变量和环境特征之间的虚假相关——这种相关并不表示因果关系。如在美国空气质量较好的亚利桑那州，由于呼吸系统疾病导致的死亡率高于全国的平均水平，这并不能说明亚利桑那的空气质量导致了高死亡率，恰恰相反，由于自我选择偏差，得了呼吸系统疾病的人往往会选择搬家至亚利桑那州，从而导致了死亡率的升高。当选择效应出现时，匆忙下结论会导致我们在现实世界中做出错误的选择。</p>
<p>&emsp;本章从第三变量、方向性问题以及选择偏差解释了相关性并不代表因果性。</p>
<h2 id="第六章-变量控制"><a href="#第六章-变量控制" class="headerlink" title="第六章 变量控制"></a>第六章 变量控制</h2><p>&emsp;本章主要介绍控制变量的重要性。</p>
<p>&emsp;科学家通过比较在不同条件下得到的结果，可以排除一些解释，并证实另一些解释。实验设计的基本目标是分离变量。科学家通过两种方法尽可能地排除不正确的理论：1.直接对实验情景进行控制。2.在可以比较各种可能解释地自然情景下进行观察。</p>
<p>&emsp;在19世纪50年代伦敦反复爆发的霍乱中，很多医生认为霍乱通过气体传播，称为“秽气理论”，但是约翰 斯诺认为霍乱通过病人排泄物污染地供水系统传播。为了证明这一点，斯诺并没有直接选择不同供水系统的居民区来进行实验，因为居民的经济水平会影响到选择的供水系统，而经济水平也会通过饮食、居住来影响到健康。斯诺选择的是在存在两种供水系统的同一片居民区中进行调查，统一居民区中人们的经济水平往往是相近的，因此这控制了经济水平这个变量。</p>
<p>&emsp;在斯诺的例子中，其使用第二种方式来排除错误的结论。在最佳的情况下，是科学家能够操纵感兴趣的变量，并且可以对其他可能影响实验的无关变量进行控制。但是斯诺并不能去改变排水系统，幸运的是他找到了一种可以控制经济变量等其它因素的情况，不过这种情况很少见。</p>
<p>&emsp;虽然斯诺的实验进行了有效的控制，但是在实验中直接操纵变量能产生更有力的推论。在斯诺的实验中，是由被试者决定自己属于哪一组实验的，即自己选择与哪一家供水公司签约，这也涉及到许多其他因素。</p>
<p>&emsp;当操纵变量与随机分配相结合是，科学家就可以排除那些归因于被试本身特征的解释了。随机分配与随机取样是不一样的。使用随机分配可以避免安慰剂效应以及选择效应等。随机实验可以通过重复验证来避免随机所产生的系统误差，因此可以得出令人信服的结论。操纵变量可以通过创设特殊条件来实现。</p>
<p>&emsp;本章主要介绍了控制变量的重要性，同时实验中通过创设特殊条件来排除其他因素的干扰并且通过随机重复实验可以得到令人信服的结论。</p>
<h2 id="第七章-“这不是真正的生活！”"><a href="#第七章-“这不是真正的生活！”" class="headerlink" title="第七章 “这不是真正的生活！”"></a>第七章 “这不是真正的生活！”</h2><p>&emsp;本章主要针对心理学的几点质疑做了科学的解释。</p>
<p>&emsp;首先，针对心理学实验中的非自然性的批评，作者指出科学实验的人为性并不是一种缺点，非自然的实验使得心理学家可以控制变量，从而得到可信的数据，虽然在非自然情况下取得的理论研究暂时不能直接应用到实际生活中，但是，理论到实际的应用是需要很多时间的，同时许多实际应用也间接的使用到这些理论。</p>
<p>&emsp;其次，针对心理学实验中并没有全部使用到随机取样得到问题，作者指出在应用研究中，其目的是预测一个非常具体的情景中的一个特定行为，如民意选举等，由于应用性质是直接的，样本的随机性和实验条件的代表行问题就很重要。同时，随机取样和随机分配是不同的。如果研究中使用了随机分配，那么它就是一项真实验，如果没有使用，则是相关研究。</p>
<p>&emsp;最后，针对“大二学生”问题，即在一些研究中，参与研究的被试为美国大学中的一些大二学生，质疑这些研究的结果是否具有推广性。作者承认这是一个研究中的问题，但是也指出1. 更加广范围的研究会完善这些理论研究，而不会完全去否定原有的研究结果；2. 许多心理学研究的是一些基本的如视觉系统，所有人的这些特征是相似的，因此对于这些研究其完全不是问题；3.研究结果的可重复性保证了其研究可以推广到不同地理区域中、社会经济地位等人群中。互联网的发展也为大二学生问题提供了一个有效的解决途径，可以通过互联网来对不同区域、不同背景的人体进行实验，同时，也有大量的实验证明心理学许多研究领域中的研究成果和之前的实验结果是相似的。但是，肯定会存在不同的实验结果，这也是推动所有科学发展的必经过程。</p>
<p>&emsp;作者在本章中也指出虽然许多实验在动物中实现，但是人类的行为与动物行为得出的规律非常地相似！ </p>
]]></content>
      <categories>
        <category>Psychology</category>
        <category>How to think about psychology</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>心理学</tag>
        <tag>这才是心理学</tag>
      </tags>
  </entry>
  <entry>
    <title>How to think about psychology-3-4</title>
    <url>/2021/05/28/How-to-think-about-psychology-3-4/</url>
    <content><![CDATA[<h1 id="这才是心理学（2-3）How-to-think-about-psychology"><a href="#这才是心理学（2-3）How-to-think-about-psychology" class="headerlink" title="这才是心理学（2-3）How to think about psychology"></a>这才是心理学（2-3）How to think about psychology</h1><h2 id="第三章-操作主义与本质主义"><a href="#第三章-操作主义与本质主义" class="headerlink" title="第三章 操作主义与本质主义"></a>第三章 操作主义与本质主义</h2><p>&emsp;操作主义是指科学理论的概念必须以某种方式建立在可观察事件的基础之上，或与之相关联，而这种可观察时间是可以被测量的。</p>
<p>&emsp;本质主义认为只有从内在本质或者本质的属性对现象做出终极的解释的理论，才是好的科学理论。</p>
<p>&emsp;科学家为操作主义者而不是本质主义者，因为他们并不尝试去回答任何关于“本质”的问题，同时这也不是科学本来面目，科学的独特优势提供一种消除错误的方法，这些错误是我们知识库中的一部分。如果将饥饿定义为“胃里的啃咬感”，这不是操作性的定义，因为其不可测量，而将其定义为可测量的食物消化时间或者一些血糖等生理指标，就是一种操作性的定义。科学中的概念是由一组操作定义的，这也促使我们更加全面地思考问题。我们需要培养对操作性定义的细节进行深究的习惯。</p>
<span id="more"></span>
<p>&emsp;一个概念的操作性必须满足信度以及效度才会有用。信度指的是测量工具的一致性，即多次测量结果相差较小。效度指的是测量工具是否测量了它本应测量的内容，例如用鞋码测试智力，虽然鞋码的测量具有信度，但是这明显是一个荒谬的无效的测试。</p>
<p>&emsp;作者指出尽管大部分概念是间接的操作性定义，如A行为模式（与冠心病的发病率有关）通过一系列二级概念来定义，包括强烈的竞争欲望、潜在的敌意、时间紧迫感等。但是所有概念都在一定程度上通过与操作性相关联的。同时概念的定义并不是固定的，而是不断演变的。</p>
<p>&emsp;心理学术语必须有直接或间接的操作性定义。但是由于人们的“预设偏见问题”，往往忽视了操作主义的必要性。比如，在物理学中讨论磁场时，就必须有相应的方法来测量，但是在心理学中，人们提到“智力”时，往往都有自己的一份评判标准，但是对于心理学家来说，“智力”的定义往往与大众内心的评判标准不一样。由于心理学中存在许多与日常用于相同的词汇，当大众提及这些词汇时会由于预设偏见对心理学上的这种词会产生误会。</p>
<p>&emsp;同时由于人们常常要求心理学回答本质问题，如人们并不会要求科学家解释“地心引力”的本质，然而人们常常将地心引力替换为“智力”来询问心理学家，由于心理学也是一门科学，这些本质问题往往是无法回答的。</p>
<h2 id="第四章-见证与个案研究"><a href="#第四章-见证与个案研究" class="headerlink" title="第四章 见证与个案研究"></a>第四章 见证与个案研究</h2><p>&emsp;个案和见证在科学研究的最初阶段是有效的，通过其寻找一些有趣现象和关键变量是进一步研究的基础。但是，其在科学的研究后期是毫无用处的。佛洛依德工作的局限性在于其仅仅通过个案和见证提出了一些假设，但是在后期并没有摆脱个案和见证的影响，利用科学的方式对假设进行检验。</p>
<p>&emsp;安慰剂效应是见证叙述对研究毫无价值的证明之一。安慰剂效应指的是无论一种治疗方法是否有真正的治疗成分，人们都倾向于报告治疗对他们有帮助。所有类型的心理治疗都涉及安慰剂效应。人们很容易相信见证叙述，但是这对于科学的研究来说毫无用处。“鲜活性”问题也是见证叙述无法作为研究的证据。“鲜活性”问题指出没有什么比真诚的个人见证更加打动人，如报纸包导飞机坠毁事故，人们对于飞机坠毁感到可怕，但是每年死于车祸的人数比死于飞机事故的人数多得多。人们并没有感受到车祸的可怕实由于车祸分布在世界各地，媒体并不能形象地为我们展现这些车祸死者，因为他们分布在全国各地。事件的鲜活性也会对科学证据本身产生影响，如人们倾向于认为科学实验的结果包括对结果进行总结的图像往往比描述相同结果的表更加可信。</p>
<p>​    鲜活的见证如此有说服力的一个重要原因在于，人类是所谓的“认知吝啬者”，即人类在处理一个问题时倾向于选择最不费力的心理加工过程。好消息是，使用科学和统计思维来看待问题可以通过训练来达到自动化程度。</p>
<p>&emsp;“巴纳姆效应是”是使用鲜活性来反驳鲜活性的有效例子之一。例如很多人对于占卜、算命等，往往会给出一种泛化的个性化总结，而人们往往认为这种总结是针对自己的准确而独特的描述。但是，对于每个人解读都一样的“个性化解读”，很好地证明了人们的见证证据是没有价值的。</p>
<p>&emsp;见证为伪科学打开了便利之门，但是理论主张是否合理，是不能用见证叙述和个案研究的证据来判定，人们对于伪科学需要提防其危害。</p>
]]></content>
      <categories>
        <category>Psychology</category>
        <category>How to think about psychology</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>心理学</tag>
        <tag>这才是心理学</tag>
      </tags>
  </entry>
  <entry>
    <title>How to think about psychology 8-10</title>
    <url>/2021/06/01/How-to-think-about-psychology-8-10/</url>
    <content><![CDATA[<h1 id="这才是心理学（8-10）How-to-think-about-psychology"><a href="#这才是心理学（8-10）How-to-think-about-psychology" class="headerlink" title="这才是心理学（8-10）How to think about psychology"></a>这才是心理学（8-10）How to think about psychology</h1><h2 id="第八章-关联性和聚合性"><a href="#第八章-关联性和聚合性" class="headerlink" title="第八章 关联性和聚合性"></a>第八章 关联性和聚合性</h2><p>&emsp;爱因斯坦综合征：认为所有科学的进步都符合“飞跃”模式，就像爱因斯坦对物理学做出的贡献一样。</p>
<p>&emsp;关联性原则：一个新的科学理论，必须与先前已经确定的实证事实所关联，即兼容旧的事实。即使是爱因斯坦理论中存在许多概念重构，其在低俗运动情况下的解释也和牛顿理论所做的预测基本相同。我们需要警惕一些伪科学中违反了关联性原则，即声称先前的数据结论不相关。很多科学领域的进步靠的不是单一的突破，而是一系列难以描述的时断时续的过程。</p>
<p>&emsp;聚合性原则：在没有一个单独的实验可以帮助一锤定音，而是每个实验都至少帮助排除一些替代解释。可以从实验局限性和理论检验的角度分别理解聚合性原则。</p>
<span id="more"></span>
<p>&emsp;实验的局限性指出，实验总是可能以各种方式出错的，如果所有的实验都具有相似的局限性，那么实验结果就值得去怀疑，然而如果所有实验的局限性各不相同，那么所有实验得出的结果就会更加可信。聚合性原则要求我们将结论建立在大量略有差异的实验所得数据之上。</p>
<p>&emsp;理论检验指出，当一系列实验支持某个理论，同时又共同排除那些最重要的竞争理论时，研究则具有高度聚合性。虽然单一的实验并不能排除所有的替代解释，但是当所有能排除一些替代解释的实验组合起来，如果数据都呈现出某种特定的趋势，那么就能产生一个强有力的结论。即得出结论需要多个实验综合，并且评判是否具有聚合性。</p>
<p>&emsp;心理学实验的诊断性往往较低，即经常只能排除一小部分替代解释，所以得出结论需要建立在聚合性证据原则之上。需要警惕心理学中假设的证据仍然不明确时，不应当将其视为“已证实的理论”。同时针对某个实验或者部分实验的局限性，而忽略整体实验所得出的符合聚合性原则的结果的反驳，也是不可取的。在评估心理学证据时，心中要想的是科学共识，而不是重大突破，是渐进整合而不是大飞跃。</p>
<p>&emsp;聚合性原则也提醒我们，当对某个问题的初步研究结果似乎相互矛盾时，不应该绝望，这是得出真正结论、聚合所有实验的的必经之路。同时，元分析的统计技术也可以帮助将不同研究的证据组合起来形成一个结论，其使用一个通用指标来表示两个实现比较时得到的效应，从而对不同的研究效应进行比较，最后用标准的方法对结果进行统计学上的合并。心理学同医学等其他科学一样依赖于元分析得出结论。</p>
<h2 id="第九章-多重原因问题"><a href="#第九章-多重原因问题" class="headerlink" title="第九章 多重原因问题"></a>第九章 多重原因问题</h2><p>&emsp;本章主要强调人的行为是由多重原因决定的同时指出了客观承认多重原因的困难之处。</p>
<p>&emsp;作者指出任何一个特定行为都不是由一个而是由许多个不同的变量引起的。同时，多个变量造成的特定结果并不会降低变量的重要性，即使单个变量只能解释结果的一小部分。</p>
<p>&emsp;交互作用：一个自变量的效应大小可能依赖于另一个自变量水平。例如生物因素与环境因素的交互作用，只有在特定的环境因素下，给特定的人群以特定的生物因素，才可能造成某种后果。交互作用展示了造成结果的多个变量之间可能不是简单的相加。</p>
<p>&emsp;单一原因解释即人们拒绝承认多重原因，因为人们往往带有预设偏见（情感）去看待问题，认为所有原因是相互竞争的，认为强调一个原因必然会降低另一个原因的重要性。同时当不同的潜在原因依附于不同的意识形态立场时，承认多重原因的存在就会变得尤为困难。最后，由于多重原因的组合造成了某个特定的问题，因此也需要多种方法的组合才可以更加有效地解决这个问题。</p>
<h2 id="第十章-概率推理问题——人类认知的阿克琉斯之槌（弱点）"><a href="#第十章-概率推理问题——人类认知的阿克琉斯之槌（弱点）" class="headerlink" title="第十章 概率推理问题——人类认知的阿克琉斯之槌（弱点）"></a>第十章 概率推理问题——人类认知的阿克琉斯之槌（弱点）</h2><p>&emsp;作者指出我们所说的概率取视，是指有较大的可能性，但是并非所有的情况下都是如此。因此每个失败的预测并不是错误的。同时作者指出心理学揭示的几乎所有事实和关系都是用概率来表述的。</p>
<p>&emsp;“某某人”统计学：由于某些人知道有一个“某某”人与某个成熟的统计趋势相左，这个取视就会受到质疑。如吸烟问题中，吸烟者总会举出一些反例来反驳研究对吸烟有害健康的结论。人们通常使用“某某人”的论据来反驳心理学上的研究成果，但是心理学也是概率性的，其是对群体的总体趋势进行的预测，即总体预测或者统计预测。</p>
<p>&emsp;社会越复杂，人们就越需要概率思维。作者指出了概率推理中的一些常见误区：</p>
<p>&emsp;&emsp;（1）未充分使用概率信息</p>
<p>&emsp;&emsp;人们在做出决策时，具体的单个信息往往会压倒较为抽象的概率信息（也是鲜活性问题）。 人们也往往会忽略基础比率的存在。如假设1000个人中就有1个人携带HIV病毒，有一种检查可以检查出是否携带HIV但是存在5%的假阳性，即错误检查出病毒，那么随机检测1个人，其真的携带HIV的概率为多少？正确答案为约2%。具体解答为，1000人检测中有50会被错误地检测出病毒，因此最终结果为1/51.</p>
<p>&emsp;&emsp;（2）未能使用样本信息</p>
<p>&emsp;&emsp;较小的样本总是会产生更多的极端值。更多的样本往往会更加接近真实概率。</p>
<p>&emsp;&emsp;（3）赌徒谬误</p>
<p>&emsp;&emsp;人们倾向于将过去的事件和未来的事件联系起来，即原本无关的事件看成是有关的。如，若抛一枚硬币连续5次为正面朝上，第6次人们往往预测为反面朝上。但是实际是，两个事件的结果是相互独立的，一个事件的出现不会影响另一个事件出现的概率。但是人们总是错误地认为，在一个随机序列中不应出现重复或某种模式。这种错误的想法往往导致人们轻而易举的相信那些声称自己有通灵能力的人，他们就是利用人们这种错觉。但是真正的随机序列，往往在人们看来不像是随机的。</p>
]]></content>
      <categories>
        <category>Psychology</category>
        <category>How to think about psychology</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>心理学</tag>
        <tag>这才是心理学</tag>
      </tags>
  </entry>
  <entry>
    <title>指令集基本原理</title>
    <url>/2024/05/26/20240526-%E6%8C%87%E4%BB%A4%E9%9B%86%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="计算机体系结构背景"><a href="#计算机体系结构背景" class="headerlink" title="计算机体系结构背景"></a>计算机体系结构背景</h1><p>简单介绍一下，计算机体系结构狭义上是指关于指令集的设计（广义上的概念会在下一篇中定义），从我们学习的各种编程语言出发，向上是各种应用的编写，向下是程序语言如何编译成计算机所能执行的二进制文件，这里就需要和指令集打交道。高级语言一般不涉及到内存和硬件，在编译过程中指令集的体系结构会起到相当大的影响，比如调用指令集的ADD方法，在不同的指令集中有不同的实现，包括是否使用寄存器，使用多少寄存器，这会影响到程序执行速度以及程序的大小，体系结构也是主要是指令集的设计。</p>
<ul>
<li><p>桌面计算机强调涉及整数和浮点数类型的程序性能，很少考虑程序规模。</p>
</li>
<li><p>服务器主要用于数据库、文件服务器和WEB应用，浮点性能的重要性远低于整数和字符串。</p>
</li>
<li><p>个人移动设备和嵌入式应用看中成本和消耗。</p>
</li>
</ul>
<span id="more"></span>
<h2 id="指令集体系结构分类"><a href="#指令集体系结构分类" class="headerlink" title="指令集体系结构分类"></a>指令集体系结构分类</h2><p>处理器的内部存储类型包括：栈、累加器、寄存器组。指令集中如何使用这些存储操作数分为：</p>
<ul>
<li><p>栈体系结构：操作数隐式位于栈顶部</p>
</li>
<li><p>累加器体系结构：操作数为隐式累加器，即累加器的结果为自己的输入</p>
</li>
<li><p>通用寄存器体系结构只有显示操作数：要么是存储器（寄存器-存储器体结构），要么是寄存器（寄存器-寄存器体系结构，也可以称为载入-存储寄存器体系结构）。其中寄存器-存储器体系结构可以用任意指令访问存储器，寄存器-寄存器体系结构只能用载入和存储访问存储器。存储器-存储器体系结构将所有操作数都存在存储器中，今天已经不存在了。</p>
</li>
</ul>
<p>1980之后几乎所有的新体系结构都使用载入-存储寄存器体系结构。原因有三个：1.寄存器快于存储器。2.对于编译器来说，使用寄存器的效率要高于其他形式的存储器。3.寄存器可以保存变量，可以降低内存访问量、提交代码密度（寄存器的名称尾数少于内存地址的位数）</p>
<p>根据以上分类，可以找到指令集的两个特性：</p>
<ul>
<li>一个ALU（algorithm logic unit，算数逻辑单元）指令有两个还是三个操作数。在三操作数中，指令包含一个目标操作数和两个源操作数，在二操作数中，其中一个操作数即是源操作数也是目标操作数。</li>
<li>ALU指令中有多少可以是内存地址。</li>
</ul>
<p>载入-存储体系结构是（0，3），即0个内存地址和三操作数的指令集。典型的有：ARM、MIPS、RISC-V。优势：简单、固定长度指令编码，指令执行所需要的时钟数相似，因为都是操作寄存器。劣势：指令数多余指令中有存储器的体系结构。指令多，指令密度低增大了程序规模。</p>
<p>寄存器-存储器体系结构是（1，2），即1个内存地址和二操作数的指令集。典型的有：Intel 80 86。优势：无需单独的载入指令就可以访问数据，可以有很好的指令密度。劣势：由于在二元计算中源操作数会被销毁，所以操作数不是等价的，每条指令的时钟数会随操作数的位置变化。</p>
<p>目前基本上都是RISC类型的指令集体系结构，虽然Intel支持8086体系结构，但是其在内部使用硬件将8086体系结构转换为类RISC指令。</p>
<p>扩展阅读：</p>
<p>RISC-V手册·：<a href="http://staff.ustc.edu.cn/~llxx/cod/reference_books/RISC-V-Reader-Chinese-v2p12017.pdf">http://staff.ustc.edu.cn/~llxx/cod/reference_books/RISC-V-Reader-Chinese-v2p12017.pdf</a></p>
<h2 id="存储器寻址方式"><a href="#存储器寻址方式" class="headerlink" title="存储器寻址方式"></a>存储器寻址方式</h2><h3 id="解释存储器地址"><a href="#解释存储器地址" class="headerlink" title="解释存储器地址"></a>解释存储器地址</h3><p>一个体系结构必须定义如何解释存储器地址以及如何指定这些地址。</p>
<p>解释存储器地址，如何对一个较大堆行中的字节进行排序：</p>
<p>大端模式：高位字节放在内存的低地址端，低位字节放在内存的高地址端。直观上的模式。</p>
<p>小端模式：高位地址放在内存的高地址端，低位字节放在内存的低地址端</p>
<p>对齐访问，在许多计算机中，对大于1字节的对象的访问必须是对齐的。如果A mod s=0，则在字节地址A对大小为s字节对象的访问是对齐的。</p>
<h3 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h3><p>体系结构中如何指定所要访问的对象的地址。</p>
<p>体系结构至少需要支持：位移量寻址、立即数寻址和寄存器间接寻址，因为据统计这三种寻址方式使用最多。</p>
<p>参考：<a href="https://www.cnblogs.com/Hardworking666/p/17374792.html#1_10">https://www.cnblogs.com/Hardworking666/p/17374792.html#1_10</a></p>
<h2 id="操作数的类型和大小"><a href="#操作数的类型和大小" class="headerlink" title="操作数的类型和大小"></a>操作数的类型和大小</h2><p>常见的操作数类型包括：字符（8位）、半字（16位）、字（32位）、单精度浮点（1字）和双精度浮点（2字）。几乎所有的计算机都遵循了相同的浮点标准——IEEE标准754。某些特定的处理器除外。</p>
<p>对于商业应用程序，一些体系结构支持一种二进制格式，称之为压缩十进制或二进制编码十进制——用4个位对0至9的数值进行编码，两个十进制数位被压缩到两字节中。</p>
<p>参考：<a href="https://en.wikipedia.org/wiki/Binary-coded_decimal">https://en.wikipedia.org/wiki/Binary-coded_decimal</a></p>
<h2 id="指令集中的操作"><a href="#指令集中的操作" class="headerlink" title="指令集中的操作"></a>指令集中的操作</h2><p>指令集中操作包括：算数与逻辑、数据传送、控制、系统、浮点、十进制、字符串以及图形类型。执行最多的是指令集中的简单操作。</p>
<h3 id="控制流指令"><a href="#控制流指令" class="headerlink" title="控制流指令"></a>控制流指令</h3><p>控制流种类：</p>
<ul>
<li>条件分支</li>
<li>跳转</li>
<li>过程调用</li>
<li>过程返回</li>
</ul>
<h5 id="控制流指令的寻址方式"><a href="#控制流指令的寻址方式" class="headerlink" title="控制流指令的寻址方式"></a>控制流指令的寻址方式</h5><p>PC相对指令：提供一个将被加到程序计数器（PC）的位移量</p>
<p>动态寻址：如果在编译时不知道目标位置，必须有一种动态指定目标的方法。只需要给出包含目标地址的寄存器名称即可。</p>
<p>寄存器间接跳转的用途（目标地址在编译时是未知的）：</p>
<ul>
<li>case或switch语句</li>
<li>虚拟函数或虚拟方法，存在于面向对象语言中</li>
<li>高阶函数或函数指针，允许以参数的形式传递函数</li>
<li>动态共享库，允许仅当程序实际调用一个库时才在运行时加载和链接库</li>
</ul>
<h5 id="过程调用"><a href="#过程调用" class="headerlink" title="过程调用"></a>过程调用</h5><p>过程调用和返回包括控制转移，还可能设计状态保存过程，至少必须将返回地址保存在某个地方。</p>
<p>在保存寄存器时，有两种方式：</p>
<ul>
<li>由调用者保存：发出调用的过程必须宝座它希望在调用返回后访问的寄存器</li>
<li>被调用者保存：被调用的过程必须保存它想使用的寄存器</li>
</ul>
<p>由于不同过程可能是分开编译的，在编译过程中编译器想知道被调用者保存的集群器是什么时候分配的会比较困难，因此大多数编译器会采用由调用者返回。</p>
<h2 id="指令集编码"><a href="#指令集编码" class="headerlink" title="指令集编码"></a>指令集编码</h2><p>变长编码：允许对所有操作使用所有寻址方式</p>
<p>定长编码：将操作和寻址方式合并到操作吗中</p>
<p>在变长编码和定长编码之间做选择是，权衡的是程序规模和处理器译码的难易程度。更看重代码规模的架构师会选择变长编码，更看重性能的架构师会选择定长编码。</p>
]]></content>
      <categories>
        <category>CAAQA</category>
        <category>CS</category>
      </categories>
      <tags>
        <tag>CS</tag>
        <tag>CAAQA</tag>
      </tags>
  </entry>
  <entry>
    <title>初识操作系统（启动区和初始化）</title>
    <url>/2024/06/02/%E5%88%9D%E8%AF%86%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="初识操作系统"><a href="#初识操作系统" class="headerlink" title="初识操作系统"></a>初识操作系统</h1><h2 id="工具介绍"><a href="#工具介绍" class="headerlink" title="工具介绍"></a>工具介绍</h2><ul>
<li><p>GCC: GNU Compiler Collection, 可以编译多语言的编译器。编译流程：预处理-&gt;编译-&gt;汇编-&gt;链接。</p>
<ul>
<li><p>参考：</p>
<p>介绍：<a href="https://www.cnblogs.com/QG-whz/p/5456720.html">https://www.cnblogs.com/QG-whz/p/5456720.html</a></p>
<p>GCC官网：<a href="https://gcc.gnu.org/onlinedocs/gcc/index.html">https://gcc.gnu.org/onlinedocs/gcc/index.html</a></p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>NASM：NASM是一个为可移植性与模块化而设计的一个80x86的汇编器。文件格式为 xx.asm</p>
<ul>
<li><p>参考：</p>
<p>官方手册：<a href="https://www.nasm.us/xdoc/2.16.03/html/nasmdoc0.html">https://www.nasm.us/xdoc/2.16.03/html/nasmdoc0.html</a></p>
</li>
</ul>
</li>
<li><p>QEMU: 一个开源的计算机仿真器和虚拟器。可以模拟不同架构的处理器（arm、x86、risc-v），也可以作为虚拟机使用</p>
<ul>
<li><p>参考：</p>
<p>官方文档：<a href="https://www.qemu.org/docs/master/about/index.html">https://www.qemu.org/docs/master/about/index.html</a></p>
</li>
</ul>
</li>
<li><p>MAKEFILE: 批处理工具，可以通过其指定如何编译链接文件</p>
<ul>
<li>参考：<a href="http://makefiletutorial.foofun.cn/#%E6%9C%89%E4%BB%80%E4%B9%88%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88%EF%BC%9F">http://makefiletutorial.foofun.cn/#%E6%9C%89%E4%BB%80%E4%B9%88%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88%EF%BC%9F</a> </li>
</ul>
</li>
</ul>
<span id="more"></span>
<h2 id="寄存器介绍"><a href="#寄存器介绍" class="headerlink" title="寄存器介绍"></a>寄存器介绍</h2><p>介绍在8086中存在的寄存器。</p>
<p>通用寄存器：</p>
<ul>
<li>AX，accumulator，累加寄存器</li>
<li>CX，counter，计数寄存器</li>
<li>DX，data，数据寄存器</li>
<li>BX，base，基址寄存器</li>
</ul>
<p>X表示extend，因为之前的寄存器都是8位的。因此8位寄存器有：AL，AH，CL，CH，DL，DH，BL，BH。</p>
<p>另外32位通用寄存器为：EAX，ECX，EBX，EDX。</p>
<hr>
<p>索引寄存器，包含段地址的偏移量：</p>
<ul>
<li>SP，stack pointer，栈指针寄存器</li>
<li>BP，base pointer，基址指针寄存器</li>
<li>SI，source index，源变址寄存器</li>
<li>DI，destination index，目的变址寄存器</li>
</ul>
<p>32位索引寄存器为：ESP，EBP，ESI，EDI。</p>
<hr>
<p>段寄存器，作程序指令，数据或栈的基础位置：</p>
<ul>
<li>CS，code segment，代码段寄存器</li>
<li>SS，stack segment，栈段寄存器</li>
<li>DS，data segment，数据段寄存器</li>
<li>ES，extra segment，附加段寄存器</li>
<li>FS，segment part2，没用名称</li>
<li>GS，segment part3， 没有名称</li>
</ul>
<hr>
<p>状态和控制寄存器：</p>
<ul>
<li>IP，instruction pointer，指令指针寄存器，它是从 Code Segment 代码寄存器处的偏移来存储执行的下一条指令</li>
<li>FLAG : Flag 寄存器用于存储当前进程的状态</li>
</ul>
<h2 id="启动区介绍-bootloader"><a href="#启动区介绍-bootloader" class="headerlink" title="启动区介绍(bootloader)"></a>启动区介绍(bootloader)</h2><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">CYLS   <span class="built_in">EQU</span>   <span class="number">10</span></span><br><span class="line"><span class="symbol">entry:</span></span><br><span class="line">  <span class="keyword">MOV</span>   <span class="built_in">AX</span>, <span class="number">0</span>             <span class="comment">; 初始化寄存器</span></span><br><span class="line">  <span class="keyword">MOV</span>   <span class="built_in">SS</span>, <span class="built_in">AX</span></span><br><span class="line">  <span class="keyword">MOV</span>   <span class="built_in">SP</span>, <span class="number">0x7c00</span>				<span class="comment">;https://wiki.osdev.org/Memory_Map_(x86)</span></span><br><span class="line">  <span class="keyword">MOV</span>   <span class="built_in">DS</span>, <span class="built_in">AX</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 读取硬盘</span></span><br><span class="line">  <span class="keyword">MOV</span>   <span class="built_in">AX</span>, <span class="number">0x0820</span></span><br><span class="line">  <span class="keyword">MOV</span>   <span class="built_in">ES</span>, <span class="built_in">AX</span></span><br><span class="line">  <span class="keyword">MOV</span>   <span class="number">CH</span>, <span class="number">0</span>             <span class="comment">; 柱面0</span></span><br><span class="line">  <span class="keyword">MOV</span>   <span class="number">DH</span>, <span class="number">0</span>             <span class="comment">; 磁头0</span></span><br><span class="line">  <span class="keyword">MOV</span>   <span class="built_in">CL</span>, <span class="number">2</span>             <span class="comment">; 扇区2，从第二个开始读，第一个默认读取</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">readloop:</span></span><br><span class="line">  <span class="keyword">MOV</span>   <span class="built_in">SI</span>, <span class="number">0</span>             <span class="comment">; 记录失败次数的寄存器</span></span><br><span class="line"><span class="symbol">retry:</span></span><br><span class="line">  <span class="keyword">MOV</span>   <span class="number">AH</span>, <span class="number">0x02</span>          <span class="comment">; AH=0x02：读盘</span></span><br><span class="line">  <span class="keyword">MOV</span>   <span class="built_in">AL</span>, <span class="number">1</span>             <span class="comment">; 1个扇区</span></span><br><span class="line">  <span class="keyword">MOV</span>   <span class="built_in">BX</span>, <span class="number">0</span></span><br><span class="line">  <span class="keyword">MOV</span>   <span class="built_in">DL</span>, <span class="number">0x00</span>          <span class="comment">; A驱动器</span></span><br><span class="line">  <span class="keyword">INT</span>   <span class="number">0x13</span>              <span class="comment">; 调用磁盘BIOS</span></span><br><span class="line">  <span class="keyword">JNC</span>   next              <span class="comment">; 没出错跳转到next</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">ADD</span>   <span class="built_in">SI</span>, <span class="number">1</span>             <span class="comment">; 失败次数+1</span></span><br><span class="line">  <span class="keyword">CMP</span>   <span class="built_in">SI</span>, <span class="number">5</span>             <span class="comment">; 失败次数是否达到5次</span></span><br><span class="line">  <span class="keyword">JAE</span>   error             <span class="comment">; 失败次数达到5次跳转到error</span></span><br><span class="line">  <span class="keyword">MOV</span>   <span class="number">AH</span>, <span class="number">0x00</span></span><br><span class="line">  <span class="keyword">MOV</span>   <span class="built_in">DL</span>, <span class="number">0x00</span>          <span class="comment">; A驱动器</span></span><br><span class="line">  <span class="keyword">INT</span>   <span class="number">0x13</span>              <span class="comment">; 重置驱动器</span></span><br><span class="line">  <span class="keyword">JMP</span>   retry</span><br><span class="line"></span><br><span class="line"><span class="symbol">next:</span></span><br><span class="line">  <span class="keyword">MOV</span>   <span class="built_in">AX</span>, <span class="built_in">ES</span>            <span class="comment">; 把内存地址后移0x200，移动一个软盘的位置</span></span><br><span class="line">  <span class="keyword">ADD</span>   <span class="built_in">AX</span>, <span class="number">0x0020</span></span><br><span class="line">  <span class="keyword">MOV</span>   <span class="built_in">ES</span>, <span class="built_in">AX</span>            <span class="comment">; 实现ES += 0x0020的目的</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">; 扇区范围 1～18</span></span><br><span class="line">  <span class="keyword">ADD</span>   <span class="built_in">CL</span>, <span class="number">1</span>             <span class="comment">; 扇区加1</span></span><br><span class="line">  <span class="keyword">CMP</span>   <span class="built_in">CL</span>, <span class="number">18</span>            <span class="comment">; 扇区是否达到18</span></span><br><span class="line">  <span class="keyword">JBE</span>   readloop          <span class="comment">; 小于等于18扇区则跳转到readloop</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">MOV</span>   <span class="built_in">CL</span>, <span class="number">1</span>             <span class="comment">; 恢复到扇区1</span></span><br><span class="line">  <span class="comment">; 磁头范围 0～1（正面0，反面1）</span></span><br><span class="line">  <span class="keyword">ADD</span>   <span class="number">DH</span>, <span class="number">1</span></span><br><span class="line">  <span class="keyword">CMP</span>   <span class="number">DH</span>, <span class="number">2</span></span><br><span class="line">  <span class="keyword">JB</span>    readloop          <span class="comment">; 磁头未达到2则跳转到readloop</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">MOV</span>   <span class="number">DH</span>, <span class="number">0</span></span><br><span class="line">  <span class="comment">; 柱面范围 0 ～ 79</span></span><br><span class="line">  <span class="keyword">ADD</span>   <span class="number">CH</span>, <span class="number">1</span></span><br><span class="line">  <span class="keyword">CMP</span>   <span class="number">CH</span>, CYLS</span><br><span class="line">  <span class="keyword">JB</span>    readloop          <span class="comment">; 读取指定数量的柱面，未达到CYLS则跳转readloop</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 读取完毕，跳转到haribote.sys执行</span></span><br><span class="line">  <span class="keyword">MOV</span>   [<span class="number">0x0ff0</span>], <span class="number">CH</span>      <span class="comment">; 记下IPL读了多远</span></span><br><span class="line">  <span class="keyword">JMP</span>   <span class="number">0xc200</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>初始化寄存器，其中0x7c00表示程序装载的位置，可以参考链接中的内存分布图，0x00007C00 — 0x00007DFF为启动区装载地址（IBM规定）。参考：<a href="https://www.glamenv-septzen.net/en/view/6">https://www.glamenv-septzen.net/en/view/6</a></p>
<p>初始化之后为读盘操作，这里读了10个柱面，每个柱面18个扇区，2个磁头（1张软盘有80个柱面，2个磁头，18个扇区，一个扇区512字节），即C0-H0-S1 -&gt; C9-H1-S18，共180KB内容。INT指令为调用BIOS函数。</p>
<p>整体地址：</p>
<pre><code>+ 0x00007C00 -- 0x00007DFF：启动区状态地址
+ 0x000008000 -- 0x000008200：启动区内容，默认读取
+ 0x000008200 -- 0x00000E600：软盘剩下内容
</code></pre><p>一般向一个空软盘保存文件时：</p>
<ol>
<li>文件名会写在0X002600以后的地方</li>
<li>文件的内容会写在0X004200以后的地方</li>
</ol>
<p>因此磁盘的内容位于内存0X8000+0X4200=0XC200的地方，即最后的jump语句执行的地方。</p>
<h2 id="初始化介绍"><a href="#初始化介绍" class="headerlink" title="初始化介绍"></a>初始化介绍</h2><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="comment">; 有关BOOT_INFO</span></span><br><span class="line">CYLS    <span class="built_in">EQU</span>   <span class="number">0x0ff0</span>      <span class="comment">; 设置启动区</span></span><br><span class="line">LEDS    <span class="built_in">EQU</span>   <span class="number">0x0ff1</span></span><br><span class="line">VMODE   <span class="built_in">EQU</span>   <span class="number">0x0ff2</span>      <span class="comment">; 关于颜色数目的信息，颜色的位数</span></span><br><span class="line">SCRNX   <span class="built_in">EQU</span>   <span class="number">0x0ff4</span>      <span class="comment">; 分辨率X</span></span><br><span class="line">SCRNY   <span class="built_in">EQU</span>   <span class="number">0x0ff6</span>      <span class="comment">; 分辨率Y</span></span><br><span class="line">VRAM    <span class="built_in">EQU</span>   <span class="number">0x0ff8</span>      <span class="comment">; 图像缓冲区的起始位置</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">entry:</span></span><br><span class="line"><span class="comment">; 设置屏幕模式</span></span><br><span class="line">  <span class="keyword">MOV</span>   <span class="built_in">AL</span>, <span class="number">0x13</span>          <span class="comment">; VGA显卡，320x200x8 bit</span></span><br><span class="line">  <span class="keyword">MOV</span>   <span class="number">AH</span>, <span class="number">0x00</span></span><br><span class="line">  <span class="keyword">INT</span>   <span class="number">0x10</span> 							<span class="comment">; 调用bios</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">MOV</span>   <span class="built_in">BYTE</span> [VMODE], <span class="number">8</span>   <span class="comment">; 屏幕的模式</span></span><br><span class="line">  <span class="keyword">MOV</span>   <span class="built_in">WORD</span> [SCRNX], <span class="number">320</span></span><br><span class="line">  <span class="keyword">MOV</span>   <span class="built_in">WORD</span> [SCRNY], <span class="number">200</span></span><br><span class="line">  <span class="keyword">MOV</span>   <span class="built_in">DWORD</span> [VRAM], <span class="number">0x000a0000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 用BIOS取得键盘上各种LED指示灯的状态</span></span><br><span class="line">  <span class="keyword">MOV</span>   <span class="number">AH</span>, <span class="number">0x02</span></span><br><span class="line">  <span class="keyword">INT</span>   <span class="number">0x16</span>              <span class="comment">; 键盘BIOS</span></span><br><span class="line">  <span class="keyword">MOV</span>   [LEDS], <span class="built_in">AL</span></span><br></pre></td></tr></table></figure>
<p>将画面模式信息保存在内存里面，同时把像素数、颜色数、键盘信息保存在0x0ff0附近，从内存分布图上来看，这块没有被使用。</p>
<p>参考BIOS设定：<a href="https://wiki.osdev.org/BIOS">https://wiki.osdev.org/BIOS</a></p>
<h3 id="MAKEFILE详解："><a href="#MAKEFILE详解：" class="headerlink" title="MAKEFILE详解："></a>MAKEFILE详解：</h3><p>来源：<a href="https://github.com/ghosind/HariboteOS">https://github.com/ghosind/HariboteOS</a></p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">AS		:= nasm</span><br><span class="line">CC		:= $(GCCPREFIX)gcc</span><br><span class="line">LD		:= $(GCCPREFIX)ld</span><br><span class="line"></span><br><span class="line">ipl<span class="selector-class">.bin</span>:</span><br><span class="line">	$(AS) -f bin ipl<span class="selector-class">.asm</span> -o ipl<span class="selector-class">.bin</span> -l ipl.lst</span><br><span class="line"></span><br><span class="line">asmhead<span class="selector-class">.bin</span>:</span><br><span class="line">	$(AS) -f elf asmhead<span class="selector-class">.asm</span> -o asmhead<span class="selector-class">.bin</span> -l asmhead.lst</span><br><span class="line"></span><br><span class="line">bootpack<span class="selector-class">.bin</span>:</span><br><span class="line">	$(CC) $(CFLAGS) -c bootpack<span class="selector-class">.c</span> -o bootpack.bin</span><br><span class="line"></span><br><span class="line">func<span class="selector-class">.bin</span>:</span><br><span class="line">	$(AS) -f elf func<span class="selector-class">.asm</span> -o func<span class="selector-class">.bin</span> -l func.lst</span><br><span class="line"></span><br><span class="line">haribote<span class="selector-class">.sys</span>: asmhead<span class="selector-class">.bin</span> bootpack<span class="selector-class">.bin</span> func.bin</span><br><span class="line">	$(LD) -m elf_i386 --oformat binary asmhead<span class="selector-class">.bin</span> bootpack<span class="selector-class">.bin</span> func<span class="selector-class">.bin</span> -o haribote<span class="selector-class">.sys</span> -T haribote.ld</span><br><span class="line"></span><br><span class="line">image: ipl<span class="selector-class">.bin</span> haribote.sys</span><br><span class="line">	<span class="selector-tag">dd</span> <span class="keyword">if</span>=/dev/zero of=$(IMG) bs=<span class="number">512</span> count=<span class="number">2880</span></span><br><span class="line">	<span class="selector-tag">dd</span> <span class="keyword">if</span>=ipl<span class="selector-class">.bin</span> of=$(IMG) bs=<span class="number">512</span> count=<span class="number">1</span> conv=notrunc</span><br><span class="line">	<span class="selector-tag">dd</span> <span class="keyword">if</span>=haribote<span class="selector-class">.sys</span> of=$(IMG) seek=<span class="number">33</span> bs=<span class="number">512</span> conv=notrunc （<span class="number">512</span>*<span class="number">33</span>=<span class="number">0</span>x4200）</span><br></pre></td></tr></table></figure>
<p>gcc已经做好编译汇编的操作，在haribote.sys进行链接，最后用dd命令生成img文件。</p>
<h2 id="Linux启动介绍"><a href="#Linux启动介绍" class="headerlink" title="Linux启动介绍"></a>Linux启动介绍</h2><p>内核启动过程：<a href="https://www.cnblogs.com/anywherego/p/18217546">https://www.cnblogs.com/anywherego/p/18217546</a></p>
<p>启动区需要看grub源码～</p>
]]></content>
      <categories>
        <category>30daysOS</category>
        <category>CS</category>
      </categories>
      <tags>
        <tag>CS</tag>
        <tag>30daysOS</tag>
      </tags>
  </entry>
</search>
